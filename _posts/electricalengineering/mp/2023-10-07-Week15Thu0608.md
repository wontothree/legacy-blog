---
title: "[MP] Week15"
categories:
  - ECE
  - MP
tags:
  - 2-1
toc: true
---

## review

- Ci+1 = Gi + Pi Ci
- 이전 carry가 만들어지지 않아도 만들어질 수 있다.
- 미리 하드웨어로 구현하겠다.
- 불 알제브라에서 분배법칙은 동일하게 성립한다.
- 최초 캐리만을 알아도 할 수 있다.
- 계층적으로 가면 복잡해진다.
- C3 = G3 + P3 C2
- 현실적으로 C4까지는 펼칠 수 있다. 계층적으로 구성할 때 빌딩 블록이라고 했을 때
- 룩어헤드의 실체가 어떤 레벨에 몇 개 있어야 하는가
- 저 세트 4개가 있으면 64bits 계산을 할 수 있다.
- 1번째 자리에 계산된 결과를 가지고 그 다음이 계산되는 구조가 아니다. 순차적인 구조가 아니다.
- 첫 번째 단에서 입력들이 약간의 gate dalay가 생기지만 동시에 인가된다. gate 3 2 등
- 이렇게 꼭 해야 하나요? 그림이 이렇게 그려져야 하나요?
- 안의 하드웨어가 복잡하니까 ripple시키는 구조를 만들겠다. 마지막 sum bit
- riiple carry adder가 carry lookahead adder가 더 빠를 수도 있지 않을까?
- 빌딩 블록으로 생각하자.
- divide conquer를 해야 한다.
- 어떤 것이 더 최적일까?
- 두 번쩨 있는 lookahead에 들어갔을 때
- C12, C8을 계산할 때 ripple carry adder보다 빠르다.
- carry lookahead adder에서는 5 gate delay 후도 도착한다.
- C1이 @4 후에 도착한다는 것을 계산할 수 있어야 한다.*****
- C1 = G0 + P0 C0 = G0 + P0 C0 = G3 + P3 G2 + P3 P2 G1 + P3 P2 P1 G0
- 5개 입력 or gate가 있다고 가정한다면 gate delay 1을 가지므로 @3에 준비된다.
- 각각의 하드웨어가 다른 곳에 있다.
- 증명할 때 expention을 하고 timing 분석을 할 때는 원래 것을 한다.
- C0가 나올 때까지 펼친다.
- C3'에 대해서도 C0까지 expenstion을 해서 얻을 수 있다. or의 각 항의 delay를 계산해서 구할 수 있다.
- 윗 계산에서는 ripple carry adder보다 빠르다.
- C4가 @3에 나왔는데 계층 구조에서는 @4에 나온다.
- C3에서 carry lookahead가 ripple carry adder보다 빠르다는 것을 계산할 수 있다. 5보다 빠를까 느릴까?

- Q. 중간고사 범위도 출제되나요?

- C2 = G1 + P1 G0 + P1 P0 C0
- 세 번째 단 입장에서 ripple이 나을까 아니면 carry lookahead 방식이 더 좋을까?
- 두 번재 단까지는 ripple이 더 유리하지만 세 번째부터는 lookahead가 유리하다.
- 3 2 2 2 2 = 11
- C0가 3에 들어왓다고 했을 때
- 최종은 @8에 나온다. 최종적인 계산이 중요하므로 중간 단계에서 일찍 출력되었다고 좋은 것이 아니다.
- 64bits로 가면 훨씬 더 느려진다. 그래서 ripple을 못쓴다.
- mux: multiplexer 2중에 하나를 선택한다. 하드웨어를 중복적으로 사용하기 위함이다.
- 2:1 mux는 gate delay가 2개다.
- ripple carry adder는 carry lookahead adder
- 2^32 = 4giga byte
- 스마트폰까지 64bit processor다.
- 이 processor에 들어간 adder다.

- 동일한 carry adder를 중복하고 선택한다.
- 세 번째 단 [11-8]부터 차이가 생긴다.
- 4번째 단에서 생각해보면
- 4에 노왔다. select adder를 구성하는 것이 도움이 된다.

## input-output communication

- input sensing은 전자장치가 아닐 수 있다.
- rpm(rotation per minute):
- controllor: device를 조종하는 유닛
- 일반적으로 processor라고 하면 main processor라 부르고 controler도 processor다.
- controller가 결국 processor의 명령을 받아와야 한다.
- interface와 동작 방식은 어떻게 될까?
- processor는 하나의 component니까...
- 큰 그림을 이야기해보자
- component 사이의 연결 고리: interconnector
- interconnect보다 bus라는 말을 더 많이 사용한다. 공통된 경유 하나만을 공유한다.
- 메모리에 비해 느린 장치인 io 장치들을 bus로 연결했다.
- 대표적인 bus 장치가 pc다.
- 많은 빠른 io 장치들을 보게 된다.
- 프로세스의 속도 최적화
- real data processing
- Processor, Cache도 중요하지만 io controller 도 중요해지고 있다.
- 요즘 문제는 전력 문제다.
- 현재 기술의 가장 큰 문제는 발열 문제다. 더 넣었다가는 칩이 망가진다. 열역학 법칙에 의해 한계가 있다.
- 액화질소를 이용하는 컴퓨터도 대두되고 있다.
- 통신하는 물리적인 것의 대표적인 것이 bus다.
- 경로를 share한다. 가 핵심 키워드다.
- 각 도시와 도시를 잇는 국도가 그물처럼 있다면...
- bus는 확장성의 문제가 있어서 프로세서가 많아지면 잘 안 쓰인다.
- 대개 core 12개를 넘어가면 bus가 아닌 network을 사용한다. 성능 병목 때문에 확장 가능성이 떨어진다.
- shared communication immediate
- 버스가 어떻게 구현되었을까?
- 각각의 레지스터가 하나의 bus master라고 생각하면 된다.
- 버스는 항상 아빗터가 있다. 아빗츄에잇을 해주는 것이다.
- 0번을 select했다는 것은..
- 공통 고속도록가 있고 나뉘는 부분이 있다. bus master 3개가 있을 때
- select하는 애가 잡아서 one adder time
- 공통된 부분이 많아서 비용이 작다.
- Three state buffer: 원래 값을 그대로 전달하는ㄴ 것 enable signal = 1일때만
- 이걸로 각각의 n 비트를 결합해도 wire에 아무 문제가 없다.
- undefine되기 때문에 말이 안 된다. 원래는
- 그래서 2:1 mux가 필요했다.
- Three - state Bus가 있는 것이다. 남에게 영향을 주지 않는다. n개 중에 하나를 select해주면 손쉬운 mux 역할을 할 수 잇다.
- 실제 하드웨어가 이해하는 instruction을 이해하는 것이 목적, datapath와 signal을 하는 것이 목적(part2) -> 그래서 gate level 이야기가 나오는 것이다.
- 실체가 무엇일까? -> Three state buffer
- processor가 선택된 하나의 processor가 독점해서 전송한다.
- 오로지 그 경로만을 담당한다.
- network: 인터넷 네트워크에서 정의와 회로에서 네트워크는 다르지만 여러가지가 있다는 늬앙스에서 비슷하다.
- 원래 내가 가지고 있는 경로로 전달하면 된다.
- 0을 선택하면 된다.
- 그 외에 데이터 전송도 활발하게 이루어질 수 잇다.
- bus에서는 p0가 선택을 하고 전송을 다한 후 넘어갈 수 잇다.
- dedicate의 장점: 동시에 transistional할 수 있다.
- 단점: 경로가 개별적으로 있어야 한다면 wire가 많아진다.
- bus와 비교하더라도
- 언제든지 통신을 보장하려면 동시에 전달하려면 여러개가 transfer될 수 있다.
- 파워까지 따져서 몇 개면 mux가 몇 개 있어야 한다를 따지기 힘들 수 있더라도 network을 가지려면..
- Introduction에서 파란 박스에 대한 이야기를 했다.

- 어떤 식의 protocol을 가지고 통신할까?(중요한 부분)
- 프로토콜로서 이야기하는 것이 interrupt 기반이다.
- instruction이 on by one 수행되는 데 io 장치가 끼어든다. processor가 instruction을 수행하지 못하도록
- 바로 알 수 있다는 장점이 있다.
- 프로세서가 더 많은 걸 수행하다고
- interrupt를 processor에 요청하면 된다.
- interrupt가 왔을 때 생성되는 function
- pin 0->1: PC값이 오버라이드된
- interruptrk 3개 있었다면 나라고 알려주는 코드를 만든다.
- interrupt가 걸리면 eventhandler가 작동해야 한다.
- interrupt가 핸들링을 하게 된다면 끼어듬을 당하는 것이지 깨문에 잡이 없음
- 언제 무슨 일이 생길지 모르는 시스템이 된다.
- interrupt를 허용하면...
- 굉장히 중요한 logic을 할 때는 interrupt를 다 끈다.
- 중요한 일 끝난 후에 interrupt를 킨다.
- 반면에 poling: io에 대한 처리가 더 중요하기 때문에 processor가 io만 바라보고 있는 것이다.
- 우편함을 주기적으로 체크하는 것과 같다.
- 아침, 점심, 저녁 한 번씩 주기적으로 체크하다가 notification을 받는 것이다.
- 시생적으로 interrup hanler가 pollingㅂ보다 느리다. bus를 쓸 데 없이 잡니다.
- interrput 라인이 interconnect 별로의 라인이 있다.
- status register,
- bus의 특징: one error time
- 혼자서 버스를 잡고 있어서 다른 것들은 버스를 이용하지 못한다.(bus의 단점)
- polling : 다른 거 못하면서 그것만 busy waiting / 장: 모든 것을 할 수 있다.
- 대부분의 실시간 시스템에는 real time system
- 대부분 polling이다.
- interrupt는 그렇게 필요없다. i0보다 다른 일을 할 때 필요할 때
- polling이 io를 중하게 본다.
- 메모리 맵드는 이야기를 못했다.
- polling을 한다고 했을 때 프로세스가 어떻게 접근할까
- 주소값을 할당받아서 똑같이 읽을 수 있는 시스템 memory-maped-io(범위밖)
- intel io -> 별도의 메모리 ....?
- 핵심은 interconnect의 큰 종류인 bus와 con.. / interrupt와 polling
