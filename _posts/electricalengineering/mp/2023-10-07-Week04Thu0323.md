---
title: "[MP] Week04"
categories:
  - ECE
  - MP
tags:
  - 2-1
toc: true
---

26.page ~

변수

- 주고가 실질적인 식별자
- 타입은 변수의 사이즈를 말해준다.

## Load instructions

- word는 4바이트, 더블 word는 8바이트
- n비트 프로세서가 의미하는 것은 register 하나의 크기가 n 비트다.
- x3의 4번째에 넣어라.

## Memory Operand Example 1

- 프로그램도 메모리에 있고 변수도 메모리에 있다. 프로그램을 위한 메모리나 변수를 위한 메모리가 따로 있는 것이 아니다.
- word는 4byte고 double word는 8byte다. 가장 작게 저장하고 로딩할 수 있는 단위가 1byte(8bit)다. 3bit만 가공하고 싶다 해도 일단 8bit를 가져온다.

## Byte-addressed / Word-aligned

- 이차원 배열처럼 생각할 수 있다.
- 바이트 주소로 4의 배수로 시작해서 쌓여 있다.
- 22번지부터 시작했다면 즉, 4의 배수가 아니라면, word aligned되어 있지 않다고 한다.
- 4의 배수가 아닌 다른 주소에 저장하면 2번 로딩 혹은 저장해야 한다. 그래서 이것을 허용하지 않는 것이 대부분이지만 risc는 허용한다.

- 8bit보다 작은 bit를 가져오고 싶더라도 1byte단위로 가져와야 한다.
- 16진수는 0~9까지는 동일하게 사용하고 a, b, c, d, e, f를 사용한다. 0xc면 12번지에 해당한다.
- 0x4: 4byte 번지라고 읽는다.
- 0x2 bits <- 이런 것은 존재하지 않는다.
- word의 원래 의미는 컴퓨터에서 가장 많이 사용하는 자료형이지만 책에서는 4byte를 의미한다.
- integer로 선언되었다면 4byte다.
- word로 aligin되었다면 4byte 단위로 선언된 것이다.

- Q. C에서 2byte를 어떻게 선언하나? -> A. short로 선언한다.

## Edian

- MSB를 한 칸에서 가장 큰 주소 번지에 저장하고 LSB를 가장 작은 주소 번지에 저장할 수도 있고 반대로 저장할 수도 있다.
- 16진수를 2비트로 표현할 때는 반드시 4비트를 사용한다. 0x4는 4비트를 이용해서 표현해야 하는 것이다.
- 0x44332211 -> 44 : 1byte, 33 : 1byte, 22 : 1byte, 11 : 1byte
- Most Significant Byte: 0x44332211에서 44를 의미한다.
- Big Endian: MSB를 가장 큰 주소 번지에 저장하는 것
- Little Endian: MSB를 가장 작은 주소 번지에 저장하는 것
- 정하기 나름이고 프로세서마다 방식이 다를 수 있다.
- 우리가 아는 대부분의 컴퓨터는 Little Endian
- 중요한 것은 아니지만 알 필요가 있다. 주어진 수 중에서 MSB인지 LSB인지를 구분하는 것이 통신에서 중요하다.
- 한 층에 낭비되는 공간이 생기면 왜 안 될까? 4byte가 가장 많이 사용되므로 공간을 잘 활용하기 위한 것이다.
- int나 float여도 word가 된다.

## Variables

- 32개의 0과 1을 어떻게 보느냐에 따라 계산 과정에서의 해석 과정, 메모리 공간에서 표현되는 방식, 출력 방식이 결정된다. Q...?

## Load instructions_

- Id x3 4(x1)에서 x1은 base register. x1에 가면 64개의 bit가 있다. 거기에 4라는 offset을 더해라. 그렇게 얻어진 주소로 가라.
- register는 64개의 bit를 담는 공간이다.

## Memory Operand Example 1_

- long A[100]; -> 원소가 100개가 있어. 배열 변수와 같이 큰 공간을 차지하는 것들이 많이 사용되기 때문에 배열 변수를 선언할 때는 차지할 공간의 크기에 대한 정도를 지시해야 한다.
- A[8] -> 배열 A의 9번째 원소
- 배열 변수의 개수가 100개인 배열을 저장해줘. 시작 주소 x22라는 것을 줘야 한다.
- ld x5, 64(x22): x5라는 곳에 담아라.
- add x23, x21, x5 -> x23에 담아라.

## Store instructions

- register에 있는 값을 -> memory에 저장한다.
- 방향을 s나 l로 지정한다.
- register는 주소라는 표현을 사용하지 않고 index라고 한다.

## Memory Operand Example 2

- long 타입이고 8번이니 8 x 12 = 96

- ld x5, 64(x22) -> 컴퓨터가 x5와 x22를 어떻게 인식하나?
- assembly instruction -> 사람이 이해할 수 있게 만든 것
- 1064를 시작 주소로 64(x22)를 시작 주소로 봐서 88을 x5에 넣는다.
- 64는 instruction 자체에 있는 것이다.

- 질문 ld x5, 64(x22)
- indirection
- 1000을 시작으로 두는 것은 임의로 둔 것이다. 연속된 공간을 확보해야 한다. 운영체제가 알려주는 정보를 참조해서 배열 변수의 시작 주소를 설정한다. 임의로 1000을 설정한 것이다.
- register의 인덱스 x22로 가보니 1000이 있으니 1000 + 64 = 1064을 얻는다.
- memory에서 시작 주소 1064로 찾아간다. 거기에 있는 값을 x5에 넣는다.
- 주소를 주고 값을 달라고 한다.
- Register는 프로세서 안에 있는 저장소이고 memory는 큰 저장소다.
- register에서는 index라는 말을 사용하고 memory에서는 주소라는 말을 사용한다.

- Q. 담아야 하는 값이 8byte보다 커지면 어떻게 되나?
- A. double보다 큰 자료형이 없기 때문에 double을 여러 번 사용해야 한다.

## Register Spill

- transister가 엄청나게 작기 때문에 공간적인 문제는 없다. 거기에 transister가 너무 많기 때문에 다 활용하지 못하는 경우가 많다.
- load에 대해 질문이 가장 많다. load를 이해하면 store도 이해한다.
- Q. word가 자료형이라고 하셨는데 C언어에는 word라는 자료형이 왜 없나요? -> 프로그래밍에서의 타입과 다르고 4byte를 지칭한다. 타입 중에서 4byte에 해당하는 것은 다 word다. word는 개념을 위해 사용하는 4byte를 가지는 변수 타입의 카테고리라고 보면된다.

## Immediate Operands

- register를 열어서 있는 값을 더해서 memory로 갔던 것에 반해 ..
- 작은 상수일 때 편하다.
- 예: for i++하여 순회할 때 정해진 작은 상수 만큼을 더하는데, 처음 받은 명령어 자체에서 알 수 있으면 좋다.
- instruction의 실체는 0과 1이다. 결국은 1bit로 표현된다는 것이다.
- 64비트의 명령어 길이는 32비트로 가진다. 32비트로 표현된다.
- 주소는 최대 64비트로 표현되는 가장 큰 수를 가질 수 있다.
- 32비트니까 2^32-1보다 작아야 한다.
- Immediate Operands를 만든 이유는 이러한 상황이 흔하기 때문이다.
- add가 있는데 addi를 만든 이유는 많이 발생하는 경우를 더 최적화하기 위해서다.
- 명령어를 명시하는 것에도 소중한 비트를 소비해야 한다. 32개 중에서 1를 할당해야 한다.
- 명령어는 addi로만 signed number로 본다면 최대 상한치가 절반밖에 되지 않는다.
- 팹리스 회사에서도 디자인을 잘하는 것이 훨씬 중요하다. 이런 방식으로 할 때 어떤 장점이 있는지에 대한 많은 논의가 있어야 한다.
- 지금은 미국이 모든 프로세서를 설계한다.

## Signed number

- 에 대한 이야기는 나중에 하겠다. 녹화 영상으로 올리겠다.
- 2의 보수를 만든 이유는 +과 -을 구분하지 않고 +만으로 계산을 진행하기 위함이다.
- 양수인지 음수인지는 사람에게는 중요하지만 컴퓨터에게는 중요하지 않다. 그러나 컴퓨터가 load가 store를 할 때는 중요해진다.

## RISC-V R-format Instructions

- 32개의 비트에 각 필드에 어떻게 할당할지 지정되어 있다.
- register를 많이 못 갖는 이유는 instruction의 길이가 32비트로 정해져 있기 때문이다.
- 간단한 덧셈 연산은 3개의 레지스터 instruction을 필요하다. 표현하는 데만 30비트를 쓰고 2비트만으로 답을 써야 하는데... 이것이
- 하나의 명령어의 길이가 길면 메모리에서 가져올 때 비효율적이다.
- 그래서 register가 많지 않은 것이다. 보통 32.. ARM은 16비트다.

# 궁금한 점

- Cisc vs. Risc