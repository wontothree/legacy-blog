---
title: "[Machine Learning] 개념 정리 노트"
excerpt:
categories:
  - machinelearning
---
## 이미지 분류 및 컴퓨터 비전 작업에서 사용되는 신경망 아키텍처

|Model|Idea|Feature|
|---|---|---|
|ResNet (Residual Network)|잔여 학습을 도입하여 심층 신경망에서 발생하는 그래디언트 소실 문제를 해결합니다. 잔여 블록을 사용하여 각 레이어의 입력과 출력 간의 차이를 학습합니다.|매우 깊은 신경망을 쉽게 훈련할 수 있도록 하였고, ImageNet 대회에서 우승한 모델 중 하나로 알려져 있습니다.|모든 합성곱 레이어에 3x3 커널을 사용하고, 풀링 레이어로만 구성된 간단한 구조를 갖고 있습니다. 깊은 네트워크를 구성함으로써 다양한 크기의 특징을 추출합니다.|간단하면서도 효과적인 구조로, 대용량 데이터셋에서 좋은 성능을 보이며 많은 컴퓨터 비전 태스크에서 사용됩니다.|
|VGG (Visual Geometry Group)|다양한 필터 크기의 컨볼루션을 병렬로 적용하고, 이를 합친 특징 맵을 생성합니다. 이로써 다양한 크기의 특징을 동시에 고려할 수 있습니다.|간단하면서도 효과적인 구조로, 대용량 데이터셋에서 좋은 성능을 보이며 많은 컴퓨터 비전 태스크에서 사용됩니다.|
|Inception (GoogLeNet)|다양한 필터 크기의 컨볼루션을 병렬로 적용하고, 이를 합친 특징 맵을 생성합니다. 이로써 다양한 크기의 특징을 동시에 고려할 수 있습니다.|계산 효율성과 효과적인 특징 추출을 위한 다양한 구조를 가지고 있으며, Inception 모듈이라 불리는 특징 추출 블록을 사용합니다.|
|EfficientNet|모델의 깊이, 폭, 해상도를 동시에 조절하여 효율적인 네트워크를 설계합니다. 모델 크기 조절을 통해 작은 모델에서 큰 모델까지 일반적인 학습 전략을 일관되게 적용합니다.|성능 대비 모델 크기가 작아 효율적이며, 모델 크기 조절을 통해 다양한 환경에서 사용할 수 있습니다. ImageNet에서 성능이 우수한 모델 중 하나입니다.|

## 대표적인 모델

|이미지 분류 모델|생성 모델|객체 검출 모델|자연어 처리 모델|
|---|---|---|---|
|AlexNet, VggNet, GoogleNet, ResNet|GAN(DCGAN), VAE, PixelRNN, PixelCNN|Faster R-CNN, YOLO|LSTM, GRU, Transformer|

## "training loss"와 "validation loss"

모델 훈련과 성능 평가 시에 중요한 지표입니다.

Training Loss (훈련 손실):

- 정의: Training Loss는 모델이 학습 데이터에 대해 얼마나 잘 수행되었는지를 나타내는 지표로, 주로 모델이 최적화하려는 목적 함수(손실 함수)의 결과물입니다.
- 목적: 훈련 손실을 최소화함으로써 모델은 학습 데이터에 적응하고, 주어진 작업에 대한 최적의 매개변수를 찾으려고 합니다.
- 과정: 각 훈련 배치(일부 데이터)를 사용하여 모델을 업데이트하면서 손실이 줄어들도록 조정됩니다.

Validation Loss (검증 손실):

- 정의: Validation Loss는 모델이 학습에 사용되지 않은 새로운 데이터에 대해 얼마나 잘 수행되는지를 측정한 지표입니다. 주로 훈련 데이터에 포함되지 않은 데이터로 이루어진 검증 데이터셋을 사용합니다.
- 목적: 검증 손실은 모델이 새로운 데이터에 대해 얼마나 일반화되는지를 평가합니다. 모델이 훈련 데이터에만 과적합되지 않도록 도와줍니다.
- 과정: 훈련 중에 일정한 간격으로 (에폭이 끝날 때마다 등) 검증 데이터를 사용하여 손실을 계산하며, 이를 통해 모델의 일반화 성능을 추정합니다.
관련성:

모델이 훈련 데이터에 대해 더 잘 수행되면 훈련 손실은 감소하게 됩니다. 그러나 모델이 훈련 데이터에만 치중되어 있어서 새로운 데이터에 대한 일반화 능력이 부족하면, 검증 손실은 증가할 수 있습니다.
모델이 훈련 데이터에 대해 과적합되면, 훈련 손실은 계속 감소하지만 검증 손실은 증가할 것입니다.
따라서 이 두 손실을 동시에 관찰하면 모델의 훈련 및 일반화 성능을 평가하고 조정하는 데 도움이 됩니다.
좋은 모델은 훈련 손실을 낮추면서 동시에 검증 손실을 최소화하는 모델입니다.

## CNN의 대표적인 4가지 모델처럼 대표성 있는 모델이 또 있을까?

## GAN, VAE, RNN, RBM는 Alexnet, vggnet, googlenet, resnet에 대응하는 개념이야 아니면 cnn, dmlp에 대응하는 개념이야?

GAN(Generative Adversarial Network), VAE(Variational Autoencoder), RNN(Recurrent Neural Network), RBM(Restricted Boltzmann Machine)은 CNN(Convolutional Neural Network)과 DMLP(Deep Multi-Layer Perceptron)과는 서로 다른 개념입니다. 이들은 주로 다른 유형의 신경망 아키텍처 또는 머신러닝 모델을 나타냅니다.

- GAN(Generative Adversarial Network): GAN은 생성 모델로, 주로 이미지 생성에 사용됩니다. Generator와 Discriminator 두 부분으로 구성되어 있으며, 학습 동안 서로 경쟁하면서 진짜처럼 보이는 데이터를 생성하는 것이 목표입니다.
VAE(Variational Autoencoder):
- VAE는 생성 모델로, 주로 이미지 생성 및 데이터 생성에 사용됩니다. Autoencoder의 확장으로, 데이터의 잠재 변수를 학습하고 이를 사용하여 샘플을 생성하는 데 중점을 둡니다.
RNN(Recurrent Neural Network):
- RNN은 순차적인 데이터 및 시계열 데이터에 적합한 신경망 아키텍처입니다. 시간에 따른 의존성을 갖는 데이터에 적합하며, 자연어 처리 등에 주로 사용됩니다.
- RBM(Restricted Boltzmann Machine): RBM은 비지도 학습 모델로, 주로 특징 추출 및 차원 감소에 사용됩니다. 주로 제한된 볼츠만 머신과 비슷한 형태를 갖지만, 깊은 신경망 구조의 이전 단계로 사용될 수 있습니다.

반면에, AlexNet, VGGNet, GoogLeNet, ResNet은 CNN(Convolutional Neural Network)의 대표적인 아키텍처입니다. 이들은 이미지 분류 및 특징 추출에 특화되어 있으며, 주로 컴퓨터 비전 작업에 사용됩니다. DMLP(Deep Multi-Layer Perceptron)은 다층 퍼셉트론을 나타내며, 주로 전통적인 신경망 아키텍처를 의미합니다. CNN과 DMLP는 모두 인공 신경망의 일종이지만, 주로 다른 유형의 데이터 및 작업에 사용됩니다.

## 일반적으로 딥러닝에서 사용하는 크로스 엔트로피와 같은 목적함수는 convex임에도 딥러닝 문제를 non convex로 취급하는 이유가 뭐야?

- 일반적으로 딥러닝에서 사용되는 목적 함수인 크로스 엔트로피와 같은 함수는 많은 경우 non-convex입니다. 
- 크로스 엔트로피와 같은 손실 함수들은 일반적으로 모델의 파라미터에 대한 복잡한 비선형 함수이기 때문에, 이러한 함수의 최적화 문제는 전반적으로 non-convex 최적화 문제로 취급됩니다.

여러 이유로 인해 딥러닝에서의 손실 함수는 non-convex성을 가집니다:

- 비선형성: 딥러닝 모델은 주로 비선형 활성화 함수를 사용하고, 이로 인해 전체 네트워크의 파라미터에 대한 손실 함수가 비선형성을 띠게 됩니다.
- 복잡한 모델 구조: 딥러닝 모델은 일반적으로 많은 수의 파라미터를 가지며, 심층 구조를 가질 수 있습니다. 이로 인해 최적화 공간이 복잡해지고 다양한 지역 최솟값과 평지(plateau)가 나타날 수 있습니다.
- 비 볼록성: Convex 함수는 볼록 함수이며, 볼록 함수는 국소 최솟값이 전역 최솟값과 일치합니다. 그러나 딥러닝 손실 함수들은 이러한 볼록성을 가지지 않아서 여러 개의 국소 최솟값이 있을 수 있습니다.
- 파라미터 간의 상호작용: 딥러닝 모델에서의 파라미터들은 서로 강하게 상호작용하며, 이는 최적화 과정에서 어려움을 일으킬 수 있습니다.
- 따라서, 딥러닝에서 최적화 문제를 다룰 때에는 non-convex 최적화 문제로 접근해야 합니다. 이는 지역 최솟값, 평지, 그리고 전역 최솟값을 고려해야 함을 의미하며, 이에 대한 효과적인 해결책은 다양한 초기화 전략, 학습률 조절, 정규화 등을 사용하는 것입니다.

## 목적함수가 non convex임에서 convex에서 수렴성이 보장되는 gradient descent 계열의 옵티마이저를 사용하는 이유가 뭘까?

- 지역 최솟값 대처: Non-convex 함수에서는 여러 개의 지역 최솟값이 존재할 수 있습니다. 
- Gradient descent는 현재 위치에서의 기울기 정보를 이용하여 최소값의 방향으로 이동하므로, 어떤 지역 최솟값에 갇힐 가능성이 적습니다. 
- 이는 초기값을 적절히 설정하고 학습률을 조절하는 등의 전략을 사용할 경우 더욱 적합해집니다.
- 골짜기(Plateau) 이동: Non-convex 함수에서는 매끄러운 부분이 있는 구간도 있을 수 있습니다. 
- 이러한 구간에서는 기울기가 작아져서 수렴 속도가 느려질 수 있습니다. 
- Gradient descent 계열의 옵티마이저는 현재 위치의 기울기를 활용하여 Plateau를 빠져나오는 방향으로 이동할 수 있습니다.
- 경사 하강: Gradient descent는 현재 위치에서의 기울기 정보를 이용하여 현재 위치에서의 최솟값 방향으로 이동합니다. 이것이 매 단계에서 현재 위치를 최소화하는 방향으로 가기 때문에, 경사 하강의 방향으로 수렴하게 됩니다.
- 더욱 유연한 적용: Convex 최적화 문제에서 사용되는 일부 옵티마이저들은 convexity에 의존하는 특성이 있어서 non-convex 함수에 대한 적용이 제한적일 수 있습니다. 그에 비해 gradient descent 계열의 옵티마이저는 더욱 일반적이고 유연하게 사용될 수 있습니다.
- 비록 non-convex 함수에서는 전역 최솟값을 찾는 것이 어려울 수 있지만, gradient descent 계열의 옵티마이저를 적절히 활용하여 local minimum에 갇히지 않고 최적화를 수행할 수 있습니다. 
- 이를 위해서는 초기값 설정, 학습률 조절, 정규화 등의 하이퍼파라미터를 조절하는 등의 기법이 사용됩니다.

## 딥러닝의 최적화 문제에서 목적 함수를 다항함수에 근사할 수 있을까?


네, 딥러닝의 최적화 문제에서 목적 함수를 다항 함수로 근사할 수 있습니다. 딥러닝 모델은 주로 비선형 함수를 표현하는데 사용되지만, 특히 다층 퍼셉트론 (MLP)과 같은 인공 신경망의 경우 다항 함수의 근사에도 유용하게 사용될 수 있습니다.

다항 함수로 목적 함수를 근사하는 경우, 다항식의 차수를 적절히 선택하는 것이 중요합니다. 낮은 차수의 다항식은 단순한 구조를 가지며 학습 데이터에 과소적합될 수 있습니다. 높은 차수의 다항식은 모델을 지나치게 복잡하게 만들어 과적합의 위험이 있습니다. 따라서 적절한 다항식 차수를 선택하는 것은 모델의 일반화 능력을 향상시키는 데 중요합니다.

다항 함수를 사용하는 것은 모델을 특정 구조로 제한하지 않고, 다양한 형태의 함수를 표현할 수 있게 합니다. 이는 딥러닝이 유연하게 다양한 함수 근사에 사용될 수 있는 이유 중 하나입니다.

그러나 주의할 점은, 다항 함수로 목적 함수를 근사하더라도 딥러닝의 최적화 문제가 여전히 non-convex이며, 그에 따른 어려움과 도전이 존재한다는 것입니다. 목적 함수를 다항식으로 근사하는 것은 모델의 표현 능력을 확장시킬 수 있지만, 최적화 문제의 복잡성에는 여전히 대응해야 합니다.

## 딥러닝에서 목적함수의 최솟값은 항상 0일까?

## 그레디언트 디센트를 사용할 때 최종적으로 혼자 다른 값에 수렴하는 현상이 발생할까? 그레디언트 디센트를 사용할 때 국소 최솟값에 수렴하는 현상이 자주 발생해?

## 목적함수로 크로스엔트로피를 사용한다고 할 때, 크로스 엔트로피와 딥러닝 구조가 목적함수를 결정해? 최종적인 손실함수는 선택한 목적함수와 신경망 구조에 의해서만 결정되는 거야?

최종적인 손실 함수는 주로 선택한 목적 함수와 사용된 신경망 구조에 의해 결정됩니다. 목적 함수는 모델이 풀어야 하는 문제의 성격에 따라 선택되며, 손실 함수는 모델이 훈련 데이터에서 얼마나 잘 수행되었는지를 측정하는 데 사용됩니다.

신경망 구조는 모델의 아키텍처를 결정하는데, 이는 입력 데이터를 받아서 출력을 생성하기 위한 레이어와 활성화 함수 등을 포함합니다. 신경망 구조는 목적 함수와 함께 최적화 과정에서 그레디언트를 계산하고 파라미터를 업데이트하는 역할을 합니다.

여기서 주의할 점은 목적 함수와 손실 함수는 종종 혼용되어 사용되지만, 엄밀하게 말하면 목적 함수는 전체 모델의 훈련 목표를 나타내는데 반해, 손실 함수는 개별 배치나 샘플에 대한 모델의 성능을 측정하는 데 사용됩니다.

따라서, 최종적인 손실 함수는 목적 함수와 모델의 성능 측정을 위한 손실 함수가 결합되어 사용됩니다. 이 손실 함수를 최소화하는 것이 모델 훈련의 목표이며, 이를 위해 주로 경사 하강법이나 그 변형이 사용됩니다.

## 그럼 데이터의 구조는 convexity에 영향을 주지 않아?

일반적으로 데이터의 구조는 최적화 문제의 복잡도와 convexity에 영향을 미칩니다. 데이터의 구조가 복잡하고 비선형적이면 최적화 문제가 더욱 어려워질 수 있습니다. 하지만 데이터의 구조 자체가 최적화 문제의 볼록성(Convexity)에 직접적인 영향을 주는 것은 아닙니다.

최적화 문제에서의 볼록성은 목적 함수가 볼록 함수(Convex Function)로 표현되는 정도를 나타냅니다. 볼록 함수의 특성은 어떤 두 점을 선택하더라도 선분 상의 모든 점이 함수 값보다 높거나 같다는 것입니다. 이러한 성질은 전역 최솟값이 존재하고, 지역 최솟값이 없는 경우를 의미합니다.

데이터의 구조는 목적 함수를 정의하는 데 사용되기 때문에 목적 함수 자체는 데이터의 특성을 반영합니다. 하지만 목적 함수가 볼록 함수가 아닌 경우, 최적화 문제에서 지역 최솟값이 존재할 수 있으며, 이는 최적화 과정을 더 어렵게 만들 수 있습니다.

따라서, 데이터의 구조가 최적화 문제의 어려움에 영향을 미치지만, 직접적으로 목적 함수의 볼록성에 영향을 주지는 않습니다. 최적화 알고리즘은 목적 함수의 특성에 따라 수렴 속도와 성능이 변할 수 있습니다.

## SGDM, Adagrad, RMSProp, Adam은 머신러닝만을 위해 고안된 최적화 기법이야?

아니오.

## 일반적으로 딥러닝의 목적함수는 몇 차 다항함수에 근사할 수 있어?


딥러닝의 목적 함수는 주로 비선형이고 매우 복잡한 함수이며, 대부분 고차원에서 동작합니다. 따라서, 딥러닝의 목적 함수를 일반적으로 몇 차 다항 함수로 정확하게 근사하기는 어려운 경우가 많습니다.

딥러닝 모델은 여러 층의 비선형 활성화 함수와 많은 파라미터를 가진 다층 신경망으로 구성되어 있습니다. 이러한 다층 구조는 고차원에서 매우 복잡한 함수를 모델링할 수 있는 강력한 도구입니다. 목적 함수는 주로 손실 함수로서 표현되며, 이는 모델의 예측과 실제 값 간의 차이를 측정합니다.

딥러닝에서는 비선형성을 도입하여 모델이 복잡한 패턴을 학습할 수 있도록 합니다. 따라서, 목적 함수를 일반적으로 어떤 특정 차수의 다항 함수로 정확하게 근사하기 어려운 것이 일반적입니다.

대신에, 딥러닝에서는 주로 데이터로부터 자동으로 특징을 학습하고, 매우 복잡한 함수 공간에서 효과적으로 모델을 최적화하여 목적 함수를 근사화합니다. 이는 높은 유연성과 표현력을 제공하며, 딥러닝이 다양한 복잡한 문제를 해결하는 데 효과적인 이유 중 하나입니다.

## 모델이 결정되고 목적함수를 선택하면, 복잡하지만 함수가 결정되는 것 아닐까?

네, 맞습니다. 딥러닝에서는 모델의 구조가 결정되고 목적 함수가 선택되면, 해당 구조와 목적 함수에 기반하여 최적화를 통해 파라미터가 결정됩니다. 모델의 파라미터가 결정되면, 해당 모델은 입력 데이터에 대한 예측을 수행할 수 있습니다.

딥러닝 모델은 기본적으로 매우 복잡한 함수를 모델링하는 데 사용됩니다. 모델의 복잡성은 여러 층의 신경망, 활성화 함수, 파라미터의 수 등에 의해 결정됩니다. 목적 함수는 모델이 학습해야 하는 작업에 따라 선택되며, 손실 함수로써 모델의 성능을 평가합니다.

학습 프로세스에서 모델은 입력 데이터와 목표값(레이블) 간의 차이를 최소화하는 방향으로 파라미터를 조정하며, 이를 통해 목적 함수를 근사화하고 최적화합니다. 이 과정은 역전파(backpropagation) 알고리즘을 사용하여 그레디언트를 계산하고 경사 하강법(또는 그 변형)을 통해 파라미터를 업데이트함으로써 이루어집니다.

따라서, 모델의 파라미터가 결정되면 해당 모델은 주어진 입력에 대한 예측을 수행할 수 있게 되며, 학습된 모델은 목적 함수에 기반하여 주어진 작업에 대해 일반화된 패턴을 학습합니다.

## 미니 배치

미니배치(minibatch)는 신경망에서 훈련 데이터를 작은 일부 그룹으로 나누는 것을 말합니다. 전체 데이터셋을 한 번에 처리하는 것보다 미니배치를 사용하면 계산 효율을 높일 수 있습니다.

신경망 훈련 과정에서는 입력 데이터와 해당하는 정답(label 또는 ground truth)을 사용하여 모델을 업데이트합니다. 전체 데이터셋을 한 번에 사용하는 것은 계산 비용이 매우 높을 뿐만 아니라 메모리도 많이 요구합니다. 미니배치는 이러한 문제를 해결하기 위해 전체 데이터를 작은 일부 그룹으로 나누어 사용합니다.

미니배치를 사용하면 다음과 같은 이점이 있습니다:

계산 효율: 전체 데이터셋을 한 번에 처리하는 것보다 미니배치는 계산에 있어서 효율적입니다.

메모리 효율: 전체 데이터를 메모리에 올리는 대신 작은 미니배치만 필요하므로 메모리 사용이 효율적입니다.

일반화(generalization) 향상: 미니배치는 데이터의 다양성을 보다 잘 반영할 수 있어 모델의 일반화 성능을 향상시킬 수 있습니다.

미니배치의 크기는 사용자가 정의할 수 있으며, 이 크기는 하이퍼파라미터로 간주됩니다. 일반적으로 2의 제곱수로 설정하는 것이 효율적인 경우가 많습니다(예: 32, 64, 128 등).

## 데이터와 손실함수의 관계

데이터와 손실 함수 간에는 밀접한 관계가 있습니다. 손실 함수는 모델의 예측과 실제 값 간의 차이를 측정하는데 사용되며, 이것은 모델을 훈련시키고 최적화하는 데 중요한 역할을 합니다. 아래에서 데이터와 손실 함수 간의 관계를 자세히 살펴보겠습니다.

손실 함수 정의:

손실 함수는 주어진 입력에 대한 모델의 예측과 실제 출력(또는 레이블) 간의 차이를 측정하는 함수입니다.
주로 회귀 문제에서는 평균 제곱 오차(Mean Squared Error, MSE)를 사용하며, 분류 문제에서는 교차 엔트로피 손실 함수 등이 사용됩니다.
훈련 데이터와 손실 함수:

모델은 훈련 데이터셋에서 학습됩니다. 훈련 데이터의 각 샘플은 입력과 그에 상응하는 실제 출력(레이블)으로 구성됩니다.
손실 함수는 이러한 예측과 실제 값 간의 차이를 측정하여 모델의 성능을 평가합니다.
훈련 과정에서 목표는 손실 함수의 값을 최소화하여 모델을 최적화하는 것입니다.
모델 업데이트와 경사 하강법:

손실 함수의 그래디언트(기울기)를 계산하고 이를 사용하여 모델의 매개변수를 업데이트합니다.
경사 하강법과 같은 최적화 알고리즘이 사용되어 손실 함수를 최소화하는 방향으로 모델을 조정합니다.
손실 함수의 역할:

손실 함수는 모델이 얼마나 잘 수행되고 있는지를 측정하는 척도로서 기능합니다.
모델이 높은 성능을 나타내면 손실이 낮아지고, 성능이 낮아지면 손실이 높아집니다.
일반화와 과적합:

손실 함수는 모델이 훈련 데이터에 과적합되지 않고 새로운 데이터에 일반화될 수 있도록 도와줍니다.
과적합은 모델이 훈련 데이터에 지나치게 적합하여 새로운 데이터에 대한 성능이 떨어지는 현상을 나타냅니다.
따라서 손실 함수는 모델 훈련 과정에서 핵심적인 역할을 하며, 훈련 데이터와의 관계를 통해 모델을 지속적으로 개선하고 최적화합니다.

## 손실함수, 목적함수, 비용함수의 차이


손실 함수(loss function), 목적 함수(objective function), 그리고 비용 함수(cost function)는 머신러닝 및 딥러닝에서 사용되는 용어로서 유사한 의미를 갖지만 약간의 차이가 있습니다. 여러 문헌이나 컨텍스트에 따라 이 용어들이 사용되는 방식이 다를 수 있지만, 일반적으로는 다음과 같은 차이를 설명할 수 있습니다:

손실 함수 (Loss Function):

손실 함수는 주로 개별 데이터 포인트에 대한 모델의 예측과 실제 값 간의 차이를 측정하는 함수입니다.
훈련 데이터의 각 샘플에 대해 손실을 계산하고, 이를 통해 모델을 업데이트합니다.
회귀 문제의 경우 평균 제곱 오차(Mean Squared Error, MSE)와 같은 함수가 사용됩니다.
목적 함수 (Objective Function):

목적 함수는 모델이 최적화하려는 대상을 정의하는 함수로, 훈련 데이터 전체에 대한 손실 함수의 합이나 평균으로 정의될 수 있습니다.
목적 함수는 모델의 학습 목표를 나타냅니다. 모델이 훈련됨에 따라 목적 함수를 최소화하려고 합니다.
목적 함수는 종종 손실 함수와 정규화 항(Regularization term)의 합으로 표현될 수 있습니다.
비용 함수 (Cost Function):

비용 함수는 목적 함수의 또 다른 용어로 사용되기도 합니다. 때로는 목적 함수와 비용 함수를 거의 동의어로 사용하는 경우가 많습니다.
비용 함수는 보통 훈련 데이터 전체에 대한 손실 함수의 합 또는 평균을 나타냅니다.
목적 함수와 비용 함수의 차이가 있더라도, 일반적으로는 모델의 최적화에 사용되는 함수로서 비슷한 역할을 합니다.
종합하면, 손실 함수는 개별 데이터 포인트에 대한 모델의 성능을 측정하고, 목적 함수 또는 비용 함수는 모델이 최적화하고자 하는 전체 목표를 나타내는 함수입니다. 이 용어들은 때때로 혼용되지만, 특정 컨텍스트에서는 구체적인 의미를 가지고 사용될 수 있습니다.

## 그레디언트 디센트는 데이터로부터 목적함수의 최저값을 찾아가는데 데이터가 목적함수 위의 점이 아닌데 어떻게 가능해

## 데이터로부터 현재 위치에서 목적함수의 기울기를 어떻게 계산할 수 있어?

그레디언트 디센트 과정에서 로스 함수를 가중치에 대해 미분하는데, 이때 데이터가 이용된다.

최종적으로는 가중치가 업데이트 된다.

가중치가 업데이트된다. <-> 함수의 최저점을 찾아간다.

## 딥러닝에서는 목적함수을 선택할지라도 신경망의 복잡한 구조로 인해 목적함수가 명확하게 알려지지 않은 상황을 가정한다. 목적함수를 알려진 다항함수로 가정하고 실험을 진행하는 것이 의미가 있을까?

연구 주장과 목표:

주장: SGD, SGDM, Adagrad, RMSProp, Adam에 대한 통합적인 관점 제시
목표: 옵티마이저의 더 깊은 해석 제공
실험 계획:

정돈된 수학적 예제(다항함수)에 대한 5가지 옵티마이저의 수렴성 비교
통제된 실험에서 각 옵티마이저의 수식과 역할 경험적으로 평가
목적 함수의 선택과 의미:

딥러닝에서 목적 함수가 명확하지 않은 경우
실험에 목적 함수로 다항함수를 사용하는 이유에 대한 고려
목적 함수 선택의 고려사항:
실용적인 접근:

딥러닝에서 목적 함수가 명확하지 않더라도, 실험을 수행하기 위해 실용적이고 이해하기 쉬운 목적 함수를 선택하는 것은 일반적입니다.
다항함수는 옵티마이저 동작을 시각화하고 이해하는 데 도움이 될 수 있습니다.
해석 가능성 강화:

목적 함수를 다항함수로 정의하면, 각 계수와 항의 역할을 명확하게 이해할 수 있습니다. 이는 각 옵티마이저의 수렴 특성을 더 잘 이해하는 데 도움이 될 수 있습니다.
비교 가능성:

목적 함수를 다항함수로 선택하는 것은 옵티마이저 간의 비교 및 해석을 위해 유용할 수 있습니다. 그러나 딥러닝에서는 목적 함수가 명확하지 않은 경우가 많기 때문에, 이러한 결과를 실제 상황에 일반화하기 위해서는 추가적인 고려가 필요합니다. 따라서 실험 결과를 해석하고 일반화하기 전에, 목적 함수의 선택이 연구의 목표 및 실제 응용에 어떤 영향을 미칠지 신중하게 고려하는 것이 중요합니다.

## 만약에 목적함수가 다항함수로 완벽하게 알려져있다고 가정한다면, 이 상황에서 미니배치는 어떤 것에 해당해?

만약 목적 함수가 다항함수로 완벽하게 알려져 있다면, 미니배치(minibatch)의 개념은 실제로 필요하지 않을 수 있습니다. 미니배치는 대부분의 경우 대량의 데이터셋에서 목적 함수를 계산하는 데 효율적인 방법으로 사용되며, 특히 딥러닝에서 널리 사용됩니다. 그러나 목적 함수가 다항함수로 정확하게 알려져 있다면, 다음과 같은 상황이 있을 수 있습니다:

배치 최적화 (Batch Optimization):

목적 함수를 다항함수로 알고 있다면 전체 데이터셋에 대한 목적 함수의 값을 한 번에 계산할 수 있습니다. 이 경우, 미니배치 대신에 전체 데이터셋에 대한 배치 최적화를 수행할 수 있습니다.
계산 효율성:

미니배치를 사용하지 않는다면 각 반복마다 더 많은 계산이 필요하지만, 목적 함수가 다항함수로 정확하게 알려져 있다면 이를 통해 전체 데이터에 대한 목적 함수를 효율적으로 계산할 수 있습니다.
수렴 속도:

목적 함수가 정확하게 알려진 경우, 전체 데이터를 고려한 최적화가 이루어지므로 일반적으로 더 빠른 수렴이 가능할 수 있습니다.
미니배치 하이퍼파라미터 튜닝의 필요성 감소:

미니배치 사용 시에는 미니배치 크기와 관련된 하이퍼파라미터를 조절해야 합니다. 목적 함수를 완벽하게 알고 있다면, 이러한 튜닝이 필요하지 않을 수 있습니다.
물론 목적 함수가 다항함수로 완벽하게 알려져 있다는 가정은 실제 상황에서 드물며, 많은 경우 목적 함수에 대한 정보가 부족하거나 복잡한 경우가 많습니다. 따라서 목적 함수를 얼마나 알고 있는지에 따라 최적화 방법을 선택하는 것이 중요합니다.

## 이 상황에서 그렇다면 스토케스틱 그레디언트 디센트를 어떻게 사용할 수 있어? 


만약 목적 함수가 다항함수로 완벽하게 알려져 있다면, 스토케스틱 그레디언트 디센트(SGD)를 어떻게 사용할지에 대한 고려 사항은 다르게 나타날 수 있습니다. 스토케스틱 그레디언트 디센트는 전체 데이터셋이 아닌 미니배치에 대한 그레디언트를 이용하여 모델을 업데이트합니다. 그러나 목적 함수를 완벽하게 알고 있다면 다음과 같은 점을 고려할 수 있습니다:

미니배치 크기 선택:

목적 함수를 완벽하게 알고 있다면 미니배치의 개념이 필요하지 않으므로 미니배치 크기를 고려할 필요가 없습니다. 전체 데이터셋을 한 번에 사용할 수 있습니다.
SGD와 Batch GD 비교:

목적 함수를 완벽하게 알고 있다면 SGD와 Batch Gradient Descent (전체 데이터를 사용한 최적화) 간의 성능 비교를 고려할 수 있습니다. 목적 함수를 완벽하게 알고 있을 때는 SGD의 노이즈를 감수하고 Batch GD를 사용하는 것이 더 수렴이 빨라질 수 있습니다.
수렴 속도:

목적 함수를 완벽하게 알고 있다면, SGD를 사용할 때의 수렴 속도를 평가하고 Batch GD와의 비교를 통해 최적화 과정을 빠르게 할 수 있는지 고려할 수 있습니다.
초기화 및 학습률 조정:

목적 함수를 완벽하게 알고 있다면 초기화와 학습률 조정에 대한 검증이 더 쉬워집니다. 초기화 및 학습률이 최적화 성능에 미치는 영향을 확인할 수 있습니다.
노이즈의 영향 감소:

SGD는 미니배치에서 계산된 그레디언트의 노이즈를 포함하므로, 목적 함수를 완벽하게 알고 있다면 이 노이즈의 영향을 감소시킬 수 있는 방법을 고려할 수 있습니다.
상황에 따라 SGD를 활용하여 목적 함수를 완벽하게 알고 있는 경우에도 다양한 실험을 통해 최적의 설정을 찾아내는 것이 중요합니다.

## 미니배치 sgd를 사용할 수 없는 거야?

미니배치 SGD를 사용할 수 없다고 말씀하시는 것은 아닙니다. 목적 함수가 다항함수로 완벽하게 알려져 있다고 가정한 상황에서도 미니배치 SGD를 사용할 수는 있습니다. 다만, 미니배치 SGD를 사용할 때의 이점과 고려할 사항이 명확하지 않을 수 있습니다. 미니배치 SGD를 사용하는 이유 중 일부는 대량의 데이터셋에서도 효율적으로 학습할 수 있기 때문이지만, 목적 함수를 완벽하게 알고 있다면 전체 데이터셋을 사용하는 것도 고려할만 합니다.

미니배치 SGD를 사용하는 이유:

계산 효율성: 대규모 데이터셋의 경우 전체 데이터셋을 한 번에 처리하는 것은 계산적으로 매우 비효율적일 수 있습니다. 미니배치 SGD는 무작위로 선택한 작은 미니배치를 사용하여 계산 효율성을 높일 수 있습니다.

일반화 향상: 미니배치 SGD는 무작위로 선택한 미니배치를 사용하므로 각 반복에서의 데이터셋이 달라집니다. 이는 모델이 다양한 데이터에 노출되면서 일반화 성능을 향상시킬 수 있습니다.

수렴 속도 개선: 전체 데이터셋을 사용하는 것보다 일부만 사용하는 것이 빠르게 수렴하고 학습이 더 빠르게 이루어질 수 있습니다.

만약 목적 함수를 완벽하게 알고 있다면, 전체 데이터셋을 한 번에 사용할 수 있지만, 미니배치 SGD를 사용할 경우에도 알맞게 설정하여 실험할 수 있습니다. 설정된 미니배치 크기와 학습률 등에 따라 성능이 달라질 수 있으므로 이러한 하이퍼파라미터를 조정하여 최적의 조건을 찾는 것이 중요합니다.
>>>>>>> d3cda0af1aa6f0599c1cc3a0c46be0db70677b84

## 미니 배치

- 데이터셋을 작은 일부 그룹으로 나누어서 모델을 학습시키는 방법을 가리킵니다.
- 전체 데이터셋을 한 번에 모델에 입력하는 것이 아니라 미니배치 단위로 나눠서 모델을 학습하면서 파라미터를 업데이트합니다. 이는 몇 가지 이점을 제공합니다.
- 계산 효율성: 전체 데이터셋을 한 번에 처리하는 것보다 미니배치를 사용하면 계산이 효율적으로 이루어집니다. 특히 큰 데이터셋의 경우 메모리 부담을 줄일 수 있습니다.
- 학습의 안정성: 미니배치를 사용하면 각각의 작은 데이터 그룹에 대한 평균 오차를 계산하고 모델을 업데이트합니다. 이로써 전체 데이터셋을 사용하는 것보다 더 안정적으로 수렴할 수 있습니다.
- 일반화 성능 향상: 미니배치는 모델이 데이터의 다양한 패턴을 학습하도록 도와줄 수 있습니다. 매번 다른 미니배치를 사용하면 모델이 전체 데이터셋의 다양성을 더 잘 이해하게 됩니다.
- 미니배치의 크기는 사용자가 정의할 수 있으며, 이 크기는 하이퍼파라미터로 조절됩니다. 일반적으로 작은 미니배치를 사용하는 것이 흔하며, 이는 모델이 빠르게 업데이트되고 다양한 데이터를 더 잘 학습할 수 있도록 돕기 때문입니다.

## 어떤 문제의 convexity를 어떻게 판별할 수 있을까? 예를 들어 mnist dataset은 convex할까? 만약 그렇다면 어떻게 판별할 수 있을까? 목적함수를 convex 함수로 지정하면 되는 것 아닌가?

MNIST 데이터셋이나 다른 이미지 분류 문제는 보통 convex하지 않습니다. 왜냐하면 이미지 분류 문제는 파라미터 공간에서 비선형 결정 경계를 찾아야 하기 때문입니다. 이러한 문제는 일반적으로 non-convex 최적화 문제로 취급됩니다.

Convexity를 판별하려면 몇 가지 방법이 있습니다:

함수의 2차 도함수 확인: 함수의 2차 도함수가 양의 정부호(positive definite)인지 확인하는 것이 일반적입니다. 양의 정부호인 경우, 그 함수는 convex입니다.

접선 확인: 함수의 모든 점에서 접선이 함수의 위를 향하면 해당 함수는 convex합니다.

Jacobian 행렬 확인: 최적화 문제에서 제약 조건이 있는 경우, 제약 조건의 Jacobian 행렬이 특정 조건을 만족하면 문제가 convex일 수 있습니다.

Convex Optimization 패키지 사용: Convexity를 판별하는 데 도움이 되는 몇 가지 패키지들이 있습니다. 예를 들면, CVXPy나 CVXPY, CVX 등이 있습니다.

MNIST 데이터셋이나 이미지 분류 문제는 보통 non-convex 최적화 문제로 다루어집니다. 이들 문제에 대한 해결책을 찾기 위해서는 대부분의 경우 그래디언트 기반의 최적화 알고리즘이 사용되며, 초기값에 따라 수렴이 다를 수 있습니다.

## 목적함수를 convex 함수로 설정해도 mnist가 non convex problem인 이유는 뭘까?

MNIST 문제가 non-convex한 이유는 주로 딥러닝 모델의 파라미터 공간에서의 최적화가 어렵기 때문입니다.

MNIST 문제에서 목적 함수는 일반적으로 모델의 가중치와 편향에 대한 손실 함수로 정의됩니다. 이 손실 함수는 주어진 입력 이미지에 대한 예측과 실제 레이블 간의 차이를 측정하는데, 이를 최소화하는 최적의 모델 파라미터를 찾는 것이 목표입니다.

딥러닝 모델은 보통 여러 층의 비선형성을 가진 신경망으로 구성되어 있습니다. 이런 비선형성 때문에 전체 손실 함수는 모델 파라미터에 대해 복잡하고 non-convex한 형태를 가집니다. 이 비선형성은 목적 함수의 그래프를 여러 국지적인 최솟값(local minima)이나 안장점(saddle points)으로 가득 채울 수 있어서 최적화가 어려워집니다.

또한, 신경망의 파라미터 공간은 매우 크고 매개변수들 간의 복잡한 상호작용이 있습니다. 이로 인해 최적화 알고리즘이 전역 최솟값(global minimum)을 찾기 어렵고, 초기값에 따라 수렴하는 해가 달라질 수 있습니다.

따라서 MNIST와 같은 이미지 분류 문제에서는 non-convex 최적화 문제를 다루게 됩니다. 이는 초기값 설정, 학습률 조절 등 다양한 최적화 전략이 필요한 이유입니다.

## 0. 기계학습 Overview

### 기계학습의 핵심은 표현과 일반화에 있다

- 표현(Representation): 데이터를 어떻게 표현하고 나타낼지에 대한 개념입니다. 좋은 표현은 모델이 데이터의 복잡한 패턴과 관계를 효과적으로 학습할 수 있도록 도와줍니다. 표현은 모델이 입력 데이터를 이해하고 처리하는 방식을 결정합니다.
- 일반화(Generalization): 모델이 학습한 내용을 학습에 사용된 데이터뿐만 아니라 이전에 본 적이 없는 새로운 데이터에 대해서도 적용할 수 있는 능력입니다. 즉, 모델이 새로운 상황에서도 유용하게 작동할 수 있는 능력을 의미합니다.
- 이 문구는 데이터를 잘 표현하고, 그 표현에서 일반적인 원칙을 학습하여 새로운 데이터에 대해 적응하는 모델을 만드는 것이 기계학습의 목표라는 아이디어를 전달합니다. 좋은 표현과 일반화 능력을 갖춘 모델은 다양한 상황에서 효과적으로 작동할 수 있습니다.
